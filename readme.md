### Для решения тестового задания были использованы:
> - Spring Boot
> - Spring Security
> - Spring Data JPA
### Дополнительно использовались:
> - Model Mapper
> - JWT
> - Lombok
> - PostgreSQL

### Описание:
Выполнены все пункты указанные в доке. В виду того что это тестовое задание, 
для упрощения проверки, пользователи заполняются в БД автоматически, при помощи класса DBInit.
Для работы с БД используется Spring Data JPA, в виду отсутсвия сложных SQL запросов.
С помощью интерфейса JPA Repository был реализован слой DAO для сущностей. 
Генерация и валидация JWT происходит в компоненте JWTUtil. 
Аутентификацией с выдачей токенов и проверкой авторизации пользователя занимается Spring Security. 
Для этих целей был написан фильтр, через который собственно проходят запросы от клиентов. 
Чтобы отследить наличие в сообщении ключевого слова *"history"* с числовым значение - используется регулярное выражение.



### Endpoints:
- #### POST */api/v1/auth
Ожидает:
> {name: "имя отправителя",
>
> password: "пароль"}

вернет:

> {token: "токен"}

- #### POST */api/v1/message
Ожидает:

> Header: "Authorization : Bearer_TOKEN"
>
> *Body:* 
> 
>"{ name:"имя отправителя",
> 
>message: "текст сообщения"
}"*

вернет: 
> Status: 200 в случае успеха

Если в поле message содержится "history N" - то вернется N последних сообщений

